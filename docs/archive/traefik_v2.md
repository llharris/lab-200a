# Traefik V2

Traefik is a reverse proxy. It is quite advanced and somewhat convuluted, but very powerful. An alternative to look at which is supposed to be much simpler to get up and running is Caddy.

## Pre-requisites

* Docker engine 
* Allow traffic to ports 80, 443 and 8080 on the Docker host
  * Optionally port forward these ports to the docker host for access from the outside world.
* Working DNS

For Let's Encrypt automated certificates you'll additionally need:

* To have a legitimate registered domain
* Have the domain DNS managed by Cloudflare or one of the other supported providers

## Create a Proxy Network

For traefik to be able to proxy connections, it needs to be on the same Docker network as the services it is proxying.

`docker network create traefik_proxy`

## Static Configuration for Traefik

Create the static configuration file for traefik `config/traefik.yml`
```
## STATIC CONFIG

log:
  level: DEBUG 

  api:
    insecure: true 
    dashboard: true

  entryPoints:
    web:
      address: ":80"

  providers:
    docker:
      endpoint: "unix:///var/run/docker.sock" 
      exposedByDefault: false
```

## Traefik Compose File

Create the docker-compose file for traefik:

```
version: '3'

services:
  traefik:
    image: "traefik:v2.3"
    container_name: "traefik"
    hostname: "traefik"
    ports:
      - "80:80"
      - "8080:8080"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "./config/traefik.yml:/traefik.yml:ro"

networks:
  default:
    external:
      name: traefik_proxy
```

Run the container: `docker-compose up -d`. Check that you can access the Traefik dashboard at http://docker-host:8080. If everything was successful, you should see something like this:

![Traefik 2.3.2 Dashboard, Dark Theme](img/traefik-dashboard.png)

Add a DNS record which resolves `traefik.domain` to the docker host IP.

## Route HTTP Traffic to a docker container

Just to test the basic functionality at this point, I want to make sure I can reverse-proxy traffic through Traefik using a router to another container. Containuous the makers of Traefik provide a handy image called `whoami` which is great for this initial testing.

### Whoami Compose File

`whoami/docker-compose.yml`

```
version: '3'

services:
  whoami:
    image: "containous/whoami"
    container_name: "whoami"
    hostname: "whoami"
    ports:
      - "88:80"

networks:
  default:
    external:
      name: traefik_proxy
```
At first, we won't proxy traffic for whoami, we'll just run it up and check it out. To do this we'll need to map port 80 on the container to a different port on the host as Traefik is using 80 already. If we visit http://docker-host:88 we should see the output generated by the whoami container...

```
Hostname: whoami
IP: 127.0.0.1
IP: 172.18.0.3
RemoteAddr: 192.168.200.10:54872
GET / HTTP/1.1
Host: 192.168.200.50:88
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: en-GB,en-US;q=0.9,en;q=0.8
Connection: keep-alive
Cookie: cookieauth=MTYzODQkOCQxJDU0NWUyNTRjM2MzMjc0NWE3ZDkzMGMwYTEyMDBkYjYxJGRhYmViODU3MDJhOTViZjc4MmRmYTkxYjg5ZmZmMmVkOThjMDRjY2Y4M2UyNzIwMzk0MzA0Y2RlMjM4OWRmODE=|1604414637
Upgrade-Insecure-Requests: 1
```

Now let's modify things so we can proxy connections to whoami through Traefik. Modify the whoami docker-compose.yml, removing the `ports` section and adding in labels as follows:

```
version: '3'

services:
  whoami:
    image: "containous/whoami"
    container_name: "whoami"
    hostname: "whoami"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.whoami.entryPoints=web"
      - "traefik.http.routers.whoami.rule=Host(`whoami.home.200a.co.uk`)"

networks:
  default:
    external:
      name: traefik_proxy
```

Next, configure DNS so that the host `whoami.home.200a.co.uk` resolves to the docker host IP and then visit http://whoami.home.200a.co.uk...

```
Hostname: whoami
IP: 127.0.0.1
IP: 172.18.0.3
RemoteAddr: 172.18.0.2:55146
GET / HTTP/1.1
Host: whoami.home.200a.co.uk
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: en-GB,en-US;q=0.9,en;q=0.8
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
X-Forwarded-For: 192.168.200.10
X-Forwarded-Host: whoami.home.200a.co.uk
X-Forwarded-Port: 80
X-Forwarded-Proto: http
X-Forwarded-Server: traefik
X-Real-Ip: 192.168.200.10
```
We can now see a lot of X-Forwarded HTTP headers and from the information provided we can see that the connection is being proxied by Traefik. Compare the RemoteAddr value from this and the previous whoami output. The first without proxying was the IP of my PC. The second is the IP of the traefik container as we can see from docker inspect...

`docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' traefik`
`172.18.0.2`

The IP matches the RemoteAddr from the proxied connection to the whoami container.

### Adding TLS Termination

Next we want Traefik to handle TLS termination for our `whoami` container and make it accessible over HTTPS. Traefik has built in support for Let's Encrypt certs via acme.sh. However in most real world situations it's more likely that we'll be using internally signed certs or proper paid for ones from the likes of VeriSign etc. 

I don't have an internal CA in my lab, so I'm going to manually generate Let's Encrypt certificates and use them as though they were internally signed. As I have a wildcard certificate for my subdomain which can be used for TLS termination of all of the services I proxy through Traefik, the easiest thing for me to do is configure Traefik to use this cert as it's default. This will prevent it from generating a self-signed certificate on initial startup.

### Configuring Default Traefik Certificate

First we place our fullchain certificate into `config/cert.crt` under our traefik directory along with the private key `config/cert.key` then we need to modify our traefik compose file. Add the following volumes:

```
  - "./config/cert.crt:/cert.crt:ro"
  - "./config/cert.key:/cert.key:ro"
```
FYI mapping the cert and key to a location under a subdirectory on the container seems to break this and it will keep generating it's own self-signed certificate hence we place them in root.

Next we add an entryPoint called 'websecure' for HTTPS into `traefik.yml`
```
entryPoints:
  web:
    address: ":80"
  websecure:
    address: ":443"
```

Next we need to make sure the file provider in `traefik.yml` is configured to watch the directory in which our cert and key is placed:

```
providers:
  docker:
    endpoint: "unix:///var/run/docker.sock"
    exposedByDefault: false
  file:
    filename: "traefik.yml"
    directory: "/"
    watch: true
```

Then we need to add a TLS section to `traefik.yml`

```
tls:
  stores:
    default:
      defaultCertificate:
        certFile: "/cert.crt"
        keyFile: "/cert.key"
```

Finally we need to add labels to our whoami compose file to tell Traefik to use the websecure entryPoint and enable TLS.

```
version: '3'

services:
  whoami:
    image: "containous/whoami"
    container_name: "whoami"
    hostname: "whoami"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.whoami.entryPoints=websecure"
      - "traefik.http.routers.whoami.rule=Host(`whoami.home.200a.co.uk`)"
      - "traefik.http.routers.whoami.tls=true"
      - "traefik.http.routers.whoami.tls.domains[0].main=*.home.200a.co.uk"

networks:
  default:
    external:
      name: traefik_proxy
```
We change the label for `traefik.http.routers.whoami.entryPoints` to the value `websecure` and we added the last two labels. Stop and start the whoami and traefik containers and then access https://whoami.home.200a.co.uk

![Whoami over HTTPS](img/whoami-https.png)

## Route Traffic to another Host

Sometimes we don't want to proxy traffic to another container, but to another host on the local network. For example, deskmini on 192.168.200.254 is running a cups print server. The admin interface is exposed to the local network (192.168.200.0/24) but the Web UI is plain HTTP and there's no authentication. There are probably ways to fix those issues within cups itself, but well, that's not really the point of this is it?

### Test the basic service

If we point a browser at http://192.168.200.254:631 we get this...

![Cups Dashboard](img/cups-dashboard.png)

### HTTP Proxy CUPS via Traefik

To proxy it through Traefik, we need to modify `traefik.yml` and add a new section:

```
## DYNAMIC CONFIG

http:
  routers:
    route-to-cups-ip:
      rule: "Host(`cups.home.200a.co.uk`)"
      service: route-to-cups-ip-service
      priority: 1000
      entryPoints: web

  services:
    route-to-cups-ip-service:
      loadBalancer:
        servers:
          - url: "http://192.168.200.254:631"
```

I've already created a DNS entry which allows `cups.home.200a.co.uk` to resolve to the docker host IP on 192.168.200.50. Restart traefik. Now when I go to http://cups.home.200a.co.uk my connection is proxied via Traefik.

### HTTPS Cups

Now I want to add TLS termination in Traefik for my connection to the cups dashboard. I just need to change the section I added to `traefik.yml` as shown below:

```
## DYNAMIC CONFIG

http:
  routers:
    route-to-cups-ip:
      rule: "Host(`cups.home.200a.co.uk`)"
      service: route-to-cups-ip-service
      priority: 1000
      tls: {}

  services:
    route-to-cups-ip-service:
      loadBalancer:
        servers:
          - url: "http://192.168.200.254:631"
```

Simple as that. Restart traefik.

## Outstanding Issues

So, CUPS proxied via Traefik doesn't work very well. Once you start clicking on various links in the dashboard things start to break. I think this is more to do with the CUPS configuration. As it's not overall very important I'm going to leave it there for the time being. LH - 30/10/20.

## Authentication

We'll go back to using our `whoami` container image for now to look at authentication. There are a few different method for authentication, but I'm going to focus on BasicAuth and ForwardAuth.

### BasicAuth

BasicAuth allows you to control access to proxied services by using htpasswd to generate credentials. Create a new file: `whoami/user_credentials` containing user:password pairs as generated by htpasswd. First generate a username:password pair:

```
httpasswd -nb user1 password1 >> user_credentials
```
Next modify the traefik docker-compose.yml to mount user_credentials...
```
volumes:
  ...
  - "./config/user_credentials:/user_credentials:ro"
```
Add labels to the compose file for the container that requires BasicAuth, in this case, whoami...

```
labels:
  ...
  - "traefik.http.routers.whoami.middlewares=auth-middlewares"
  - "traefik.http.middlewares.auth-middlewares.basicauth.usersfile=/user_credentials"
```
![Whoami over HTTPS with BasicAuth](img/whoami-basicauth.png)

### Google OAuth

This requires port forwarding to the services from the outside world so that google can forward to a resolvable domain. Kind of want to keep this internal so will skip this bit for now - LH 30/10/20.

### Authelia MFA

Same story, aimed at securely accessing services from the web. Out of scope for now.

### LDAP Auth

This is most likely the one that would be of most use and most often needed, but it's only available in Traefik Enterprise :(



































### Secure Docker Endpoint

See [Socket Proxy](#socket-proxy) 

`exposedByDefault: false` means services discovered by Traefik via the docker socket won't automatically be exposed to the outside world. As such, each service must be explicitly exposed via a label in its docker-compose file `"traefik.enable=true"`

### Use a .env file

Create a .env file to abstract any environment specific values to variables and then reference them within the docker-compose.yml. 

`.env`
```
MY_DOMAIN=home.200a.co.uk
PROXY_NETWORK=traefik_proxy
```

### Create docker-compose.yml

`traefik-docker-compose.yml`
```
version: '3'

services:
  traefik:
    image: "traefik:v2.3"
    container_name: "traefik"
    hostname: "traefik"
    ports:
      - "80:80"
      - "8080:8080"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "./traefik.yml:/traefik.yml:ro"

networks:
  default:
    external:
      name: $PROXY_NETWORK
```

Running `docker-compose config` will show you what the docker-compose file looks like with those variables populated. It'll also check the syntax for you. Because we specified a non-standard name for the compose file we also need to use the -f option to specify the file: `docker-compose -f traefik-docker-compose.yml config`

```
networks:
  default:
    external: true
    name: traefik_proxy
services:
  traefik:
    container_name: traefik
    hostname: traefik
    image: traefik:v2.3
    ports:
    - published: 80
      target: 80
    - published: 8080
      target: 8080
    volumes:
    - /var/run/docker.sock:/var/run/docker.sock:ro
    - /home/llharris/docker/traefik_new/traefik.yml:/traefik.yml:ro
version: '3'
```

Now let's start Traefik: `docker-compose -f traefik-docker-compose.yml up -d`
```
Creating traefik ... done
```
Let's check the logs: `docker logs -f traefik`
```
time="2020-10-27T22:38:26Z" level=info msg="Configuration loaded from file: /traefik.yml"
time="2020-10-27T22:38:26Z" level=info msg="Traefik version 2.3.2 built on 2020-10-19T18:36:22Z"
time="2020-10-27T22:38:26Z" level=debug msg="Static configuration loaded {\"global\":{\"checkNewVersion\":true},\"serversTransport\":{\"maxIdleConnsPerHost\":200},\"entryPoints\":{\"traefik\":{\"address\":\":8080\",\"transport\":{\"lifeCycle\":{\"graceTimeOut\":10000000000},\"respondingTimeouts\":{\"idleTimeout\":180000000000}},\"forwardedHeaders\":{},\"http\":{}},\"web\":{\"address\":\":80\",\"transport\":{\"lifeCycle\":{\"graceTimeOut\":10000000000},\"respondingTimeouts\":{\"idleTimeout\":180000000000}},\"forwardedHeaders\":{},\"http\":{}}},\"providers\":{\"providersThrottleDuration\":2000000000,\"docker\":{\"watch\":true,\"endpoint\":\"unix:///var/run/docker.sock\",\"defaultRule\":\"Host(`{{ normalize .Name }}`)\",\"swarmModeRefreshSeconds\":15000000000}},\"api\":{\"insecure\":true,\"dashboard\":true},\"log\":{\"level\":\"DEBUG\",\"format\":\"common\"}}"
time="2020-10-27T22:38:26Z" level=info msg="\nStats collection is disabled.\nHelp us improve Traefik by turning this feature on :)\nMore details on: https://doc.traefik.io/traefik/contributing/data-collection/\n"
time="2020-10-27T22:38:26Z" level=info msg="Starting provider aggregator.ProviderAggregator {}"
time="2020-10-27T22:38:26Z" level=debug msg="Start TCP Server" entryPointName=web
time="2020-10-27T22:38:26Z" level=debug msg="Start TCP Server" entryPointName=traefik
time="2020-10-27T22:38:26Z" level=info msg="Starting provider *traefik.Provider {}"
time="2020-10-27T22:38:26Z" level=debug msg="Configuration received from provider internal: {\"http\":{\"routers\":{\"api\":{\"entryPoints\":[\"traefik\"],\"service\":\"api@internal\",\"rule\":\"PathPrefix(`/api`)\",\"priority\":2147483646},\"dashboard\":{\"entryPoints\":[\"traefik\"],\"middlewares\":[\"dashboard_redirect@internal\",\"dashboard_stripprefix@internal\"],\"service\":\"dashboard@internal\",\"rule\":\"PathPrefix(`/`)\",\"priority\":2147483645}},\"services\":{\"api\":{},\"dashboard\":{},\"noop\":{}},\"middlewares\":{\"dashboard_redirect\":{\"redirectRegex\":{\"regex\":\"^(http:\\\\/\\\\/(\\\\[[\\\\w:.]+\\\\]|[\\\\w\\\\._-]+)(:\\\\d+)?)\\\\/$\",\"replacement\":\"${1}/dashboard/\",\"permanent\":true}},\"dashboard_stripprefix\":{\"stripPrefix\":{\"prefixes\":[\"/dashboard/\",\"/dashboard\"]}}}},\"tcp\":{},\"tls\":{}}" providerName=internal
time="2020-10-27T22:38:26Z" level=info msg="Starting provider *docker.Provider {\"watch\":true,\"endpoint\":\"unix:///var/run/docker.sock\",\"defaultRule\":\"Host(`{{ normalize .Name }}`)\",\"swarmModeRefreshSeconds\":15000000000}"
time="2020-10-27T22:38:26Z" level=debug msg="Added outgoing tracing middleware dashboard@internal" entryPointName=traefik routerName=dashboard@internal middlewareName=tracing middlewareType=TracingForwarder
time="2020-10-27T22:38:26Z" level=debug msg="Creating middleware" middlewareType=StripPrefix entryPointName=traefik routerName=dashboard@internal middlewareName=dashboard_stripprefix@internal
time="2020-10-27T22:38:26Z" level=debug msg="Adding tracing to middleware" entryPointName=traefik routerName=dashboard@internal middlewareName=dashboard_stripprefix@internal
time="2020-10-27T22:38:26Z" level=debug msg="Creating middleware" middlewareType=RedirectRegex middlewareName=dashboard_redirect@internal routerName=dashboard@internal entryPointName=traefik
time="2020-10-27T22:38:26Z" level=debug msg="Setting up redirection from ^(http:\\/\\/(\\[[\\w:.]+\\]|[\\w\\._-]+)(:\\d+)?)\\/$ to ${1}/dashboard/" routerName=dashboard@internal entryPointName=traefik middlewareType=RedirectRegex middlewareName=dashboard_redirect@internal
time="2020-10-27T22:38:26Z" level=debug msg="Adding tracing to middleware" entryPointName=traefik routerName=dashboard@internal middlewareName=dashboard_redirect@internal
time="2020-10-27T22:38:26Z" level=debug msg="Added outgoing tracing middleware api@internal" routerName=api@internal entryPointName=traefik middlewareName=tracing middlewareType=TracingForwarder
time="2020-10-27T22:38:26Z" level=debug msg="Creating middleware" middlewareName=traefik-internal-recovery middlewareType=Recovery entryPointName=traefik
time="2020-10-27T22:38:26Z" level=debug msg="No default certificate, generating one"
time="2020-10-27T22:38:26Z" level=debug msg="Provider connection established with docker 19.03.13 (API 1.40)" providerName=docker
time="2020-10-27T22:38:26Z" level=debug msg="Filtering disabled container" container=traefik-traefik-new-841d873770b9264cbde928af0562c3dec064500c8862e0664724fa6fe08aaf80 providerName=docker
time="2020-10-27T22:38:26Z" level=debug msg="Filtering disabled container" providerName=docker container=idrac-d51b0fcc8d410aedd980ebfe4e677f2f012e568d70249cb1ee31c4c734fbd67f
time="2020-10-27T22:38:26Z" level=debug msg="Configuration received from provider docker: {\"http\":{},\"tcp\":{},\"udp\":{}}" providerName=docker
time="2020-10-27T22:38:27Z" level=debug msg="Added outgoing tracing middleware api@internal" entryPointName=traefik middlewareName=tracing middlewareType=TracingForwarder routerName=api@internal
time="2020-10-27T22:38:27Z" level=debug msg="Added outgoing tracing middleware dashboard@internal" middlewareName=tracing middlewareType=TracingForwarder entryPointName=traefik routerName=dashboard@internal
time="2020-10-27T22:38:27Z" level=debug msg="Creating middleware" middlewareName=dashboard_stripprefix@internal middlewareType=StripPrefix entryPointName=traefik routerName=dashboard@internal
time="2020-10-27T22:38:27Z" level=debug msg="Adding tracing to middleware" routerName=dashboard@internal middlewareName=dashboard_stripprefix@internal entryPointName=traefik
time="2020-10-27T22:38:27Z" level=debug msg="Creating middleware" entryPointName=traefik routerName=dashboard@internal middlewareName=dashboard_redirect@internal middlewareType=RedirectRegex
time="2020-10-27T22:38:27Z" level=debug msg="Setting up redirection from ^(http:\\/\\/(\\[[\\w:.]+\\]|[\\w\\._-]+)(:\\d+)?)\\/$ to ${1}/dashboard/" routerName=dashboard@internal middlewareName=dashboard_redirect@internal middlewareType=RedirectRegex entryPointName=traefik
time="2020-10-27T22:38:27Z" level=debug msg="Adding tracing to middleware" entryPointName=traefik routerName=dashboard@internal middlewareName=dashboard_redirect@internal
time="2020-10-27T22:38:27Z" level=debug msg="Creating middleware" entryPointName=traefik middlewareType=Recovery middlewareName=traefik-internal-recovery
time="2020-10-27T22:38:27Z" level=debug msg="No default certificate, generating one"
```
This looks OK. Accessing the dashboard URL at http://192.168.200.50:8080 gives us the following:

![](https://i.imgur.com/iVaaDgh.png)

### Testing container routing

We can test that Traefik is able to route traffic to other containers using some simple labels in our compose file. Containous (the creators of Traefik) provide a useful 'whoami' container image for the purpose of basic testing. Create a new docker-compose file:

`whoami-docker-compose.yml`
```
version: '3'

services:
  whoami:
    image: "containous/whoami"
    container_name: "whoami"
    hostname: "whoami"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.whoami.entryPoints=web"
      - "traefik.http.routers.whoami.rule=Host(`whoami.$MY_DOMAIN`)"

networks:
  default:
    external:
      name: $PROXY_NETWORK
```

We can, once again test this with `docker-compose -f whoami-docker-compose.yml config`. We also need to make sure that the host we've specified in the rule label resolves to our container host.

```
# nslookup whoami.home.200a.co.uk
Server:         192.168.200.254
Address:        192.168.200.254#53

** server can't find whoami.home.200a.co.uk: NXDOMAIN
```

Bleugh! Stick this `address=/whoami.home.200a.co.uk/192.168.200.50` in our dnsmasq.conf on our DNS server and then run `systemctl restart dnsmasq`. This now looks better:

```
# nslookup whoami.home.200a.co.uk
Server:         192.168.200.254
Address:        192.168.200.254#53

Name:   whoami.home.200a.co.uk
Address: 192.168.200.50
```

Start up the whoami container: `docker-compose -f whoami-docker-compose.yml up -d` and open http://whoami.home.200a.co.uk in a browser. We should get this:

![](img/whoami_container.png)

Yay!

If you saw a warning like this `WARNING: Found orphan containers (traefik) for this project....` ignore it. It's complaining because we potentially have compose files in the same directory. We can (and should) either move these into their own directories or combine them into one compose file.. but that might be a bit unwieldy.

## Routing traffic to not-docker-containers

So what if we want to get Traefik to reverse-proxy out connections to other stuff on our network that isn't a container. We gotchu fam!

I'd quick like to reverse-proxy my connection to Cockpit running on my CentOS machine. That might be a bit advanced at this point, because it only allows HTTPS connections. So, let's go for something a bit easier for now, like the HTTP status page for my CUPS print server :)

To do this, I'm going to need a few things:

* A DNS record for something cool and memorable like cups.home.200a.co.uk that resolves to the docker host where Traefik is running.
* A Traefik router that catches requests for the URL and splurps them to the right place.

We need to make some changes to our `traefik.yml` so it looks like this...

```
## STATIC CONFIG
log:
  level: DEBUG

api:
  insecure: true
  dashboard: true

entryPoints:
  web:
    address: ":80"

providers:
  docker:
    endpoint: "unix:///var/run/docker.sock"
    exposedByDefault: false
  file:
    filename: "traefik.yml"

## DYNAMIC CONFIG

http:
  routers:
    route-to-cups:
      rule: "Host(`cups.home.200a.co.uk`)"
      service: route-to-cups-service
      priority: 1000
      entryPoints:
        - web

  services:
    route-to-cups-service:
      loadBalancer:
        servers:
          - url: "http://192.168.200.254:631"
```

Stop and start traefik using docker-compose, then try http://cups.home.200a.co.uk.... aaaaand it doesn't work. Bad Request. Not sure if this is more to do with some weirdness on the part of the cups web service or something else. Let's test this by deploying a Apache HTTPD to the same machine and trying to reverse proxy the standard welcome page.

```
@deskmini

dnf install httpd -y && systemctl start httpd
curl localhost
firewall-cmd --permanent --add-service=http && firewall-cmd --reload
```
Now I can browse to the Apache test page. 

Modify traefik.yml and down up the compose file:

```
## DYNAMIC CONFIG

http:
  routers:
    route-to-local-ip:
      rule: "Host(`cups.home.200a.co.uk`)"
      service: route-to-local-ip-service
      priority: 1000
      entryPoints:
        - web

  services:
    route-to-local-ip-service:
      loadBalancer:
        servers:
          - url: "http://192.168.200.254:80"

docker-compose -f traefik-docker-compose.yml down && docker-compose -f traefik-docker-compose.yml up -d
```

I can now access the Apache test page by pointing my browser at http://cups.home.200a.co.uk. I checked the cups logs using `journalctl -u cups -e` and found the following:

```
Oct 27 23:08:38 deskmini.home.200a.co.uk cupsd[1197]: [Client 17] Request from "192.168.200.50" using invalid Host: field "cups.home.200a.co.uk".
```

A quick Googling revealed a workaround. Adding `ServerAlias *` to `/etc/cups/cupsd.conf` fixes this. Restarted cups service and down/up traefik after putting the configuration back to how it was and it is now working.

### Authentication

Traefik provides the concept of 'middlewares' which can do... things, among which is authentication. We can enforce authentication to access proxied services like so.

#### Create basic auth htpasswd:

```
htpasswd -nb user1 password123
user1:$apr1$mcbp6jKP$Z9HrMjXyjZdfUFV4zktUj.
```

Add the output to a file called `credentials`. Modify the traefik compose file to include an additional bind mount for the credential file...

```
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "./traefik.yml:/traefik.yml:ro"
      - "./credentials:/credentials:ro"
```
Now we need to add labels to any container that requires authentication.
```
vi whoami-docker-compose.yml

...
      - "traefik.http.routers.whoami.middlewares=auth-middleware"
      - "traefik.http.middlewares.auth-middleware.basicauth.usersfile=/credentials"
...
```
Restart the containers and now accessing http://whoami.home.200a.co.uk will prompt for a login.

### Let's Encrypt Certs via DNS Challenge

Create an empty acme.json file: 
```
touch acme.json && chmod 600 acme.json
```

Add a HTTPS entrypoint into traefik.yml
```
entryPoints:
  web:
    address: ":80"
  websecure:
    address: ":443
```

#### NOTE:

This doesn't appear to be working due to an issue with the acme.sh integration with cloudflare, or my misunderstanding of how to interact with the cloudflare API. I don't think this is necessarily a traefik issue because I can't get the DNS challenge to work just running acme.sh on its own.

However, in "Real Life" TM it's pretty unlikely we'll be utilising Let's Encrypt certificates. It's fare more likley we'll either be dealing with internally generated certs or proper purchased onces from somewhere like VeriSign. 

### Internally Signed Wildcard Certificates

I'm going to effectively simulate using an internally signed wildcard cert. I don't have an internal CA, so I'll use a cert I got from Let's Encrypt, but which was obtained manually using certbot.

I have a wildcard cert for *.home.200a.co.uk along with the full certificate chain and the private key file. I just want any service I proxy through Traefik to use TLS and have the termination handled by Traefik. I want to use the wildcard cert for all of my internal services because they're all going to be one the same home.200a.co.uk domain anyway.

First I need to edit `traefik.yml`, comment out the whole certificateResolvers section and add and modify the following part:

```
providers:
  docker:
    endpoint: "unix:///var/run/docker.sock"
    exposedByDefault: false
  file:
    filename: "traefik.yml"
    directory: "/"
    watch: true

tls:
  stores:
    default:
      defaultCertificate:
        certFile: "/cert.crt"
        keyFile: "/cert.key"
```

I've added the directory and watch directivs under the file provider. Probably shouldn't be using root as the config directory but, whatever.
Then I've added a TLS section to specify the default certificate that Traefik will use (this will be used instead of the default behaviour of it generating it's own self-signed cert on startup.

For a basic test, I want to HTTPS my whoami service, so I need to modify whoami-docker-compose.yml as follows:

```
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.whoami.entryPoints=websecure"
      - "traefik.http.routers.whoami.rule=Host(`whoami.$MY_DOMAIN`)"
      - "traefik.http.routers.whoami.tls=true"
      - "traefik.http.routers.whoami.tls.domains[0].main=*.$MY_DOMAIN"
```

I'm just changing the labels section. The main bit being to add `traefik.http.routers.<my-app>.tls=true`. Without other labels being specified to control the behaviour this will just use the default certificate which now should be my pretend internally signed wildcard one.

Finally I need to modify the compose file for traefik to make sure the cert and keyfile and bind mounted and available within the container by adding the following under volumes:

```
      - "./cert.crt:/cert.crt"
      - "./cert.key:/cert.key"
```

That's it, stop/restart whoami and traefik go to https://whoami.home.200a.co.uk

![](img/whoami-https.png)

---

## Socket Proxy

Using `"unix:///var/run/docker.sock"` isn't the most secure way to give Traefik the access it needs to the docker daemon for service discovery. Instead we can use:

```
traefik.yml
...
providers:
  docker:
    endpoint: tcp://socket-proxy:2375
```
This requires putting both traefik and a separate container instance of `fluencelabs/docker-socker-proxy` onto their own `socket_proxy`  network together. Example configuration for the socket-proxy service is:

```
...
 # Docker Socket Proxy - Security Enchanced Proxy for Docker Socket
  socket-proxy:
    container_name: socket-proxy
    image: fluencelabs/docker-socket-proxy
    restart: always
    networks:
      # t2_proxy:
      socket_proxy:
        ipv4_address: x.x.x.x # You can specify a static IP
    privileged: true
    ports:
      - "127.0.0.1:2375:2375" # Port 2375 should only ever get exposed to the internal network.
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock"
    environment:
      - LOG_LEVEL=info # debug,info,notice,warning,err,crit,alert,emerg
      ## Variables match the URL prefix (i.e. AUTH blocks access to /auth/* parts of the API, etc.).
      # 0 to revoke access.
      # 1 to grant access.
      ## Granted by Default
      - EVENTS=1
      - PING=1
      - VERSION=1
      ## Revoked by Default
      # Security critical
      - AUTH=0
      - SECRETS=0
      - POST=1 # Watchtower
      - DELETE=1 # Watchtower
        # GET Optons
      - BUILD=0
      - COMMIT=0
      - CONFIGS=0
      - CONTAINERS=1 # Traefik, portainer, etc.
      - DISTRIBUTION=0
      - EXEC=0
      - IMAGES=1 # Portainer, Watchtower
      - INFO=1 # Portainer
      - NETWORKS=1 # Portainer, Watchtower
      - NODES=0
      - PLUGINS=0
      - SERVICES=1 # Portainer
      - SESSION=0
      - SWARM=0
      - SYSTEM=0
      - TASKS=1 # Portaienr
      - VOLUMES=1 # Portainer
      # POST Options
      - CONTAINERS_CREATE=1 # WatchTower
      - CONTAINERS_START=1 # WatchTower
      - CONTAINERS_UPDATE=1 # WatchTower
      # DELETE Options
      - CONTAINERS_DELETE=1 # WatchTower
      - IMAGES_DELETE=1 # WatchTower
...
```
